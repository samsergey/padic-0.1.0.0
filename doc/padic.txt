-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast, type-safe p-adic arithmetic
--   
--   Implementation of p-adic arithmetics on the base of fast modular
--   arithmetics. Module introduces data types for p-adic integers and
--   rationals with arbitrary precision as well as some specific functions
--   (rational reconstruction, p-adic signum function, square roots etc.).
@package padic
@version 0.1.0.0


-- | Module introduces p-adic integers and rationals with basic p-adic
--   arithmetics and implments some specific functions (rational
--   reconstruction, p-adic signum function, square roots etc.).
--   
--   A truncated p-adic number &lt;math&gt; can be represented in three
--   ways:
--   
--   &lt;math&gt; where &lt;math&gt;
--   
--   In order to gain efficiency the integer p-adic number with radix
--   &lt;math&gt; is internally represented in form &lt;math&gt; as only
--   one digit &lt;math&gt;, lifted to modulo &lt;math&gt;, where
--   &lt;math&gt; is chosen so that within working precision numbers
--   belogning to <tt>Int</tt> and <tt>Ratio Int</tt> types could be
--   reconstructed by extended Euclidean method. Form &lt;math&gt; is used
--   for textual output only, and form &lt;math&gt; is used for
--   transrornations to and from rationals.
--   
--   The documentation and the module bindings use following terminology:
--   
--   <ul>
--   <li><a>radix</a> -- modulus &lt;math&gt; of p-adic number,</li>
--   <li><a>precision</a> -- maximal power &lt;math&gt; in p-adic
--   expansion,</li>
--   <li><a>unit</a> -- invertible muliplier &lt;math&gt; for prime
--   &lt;math&gt;,</li>
--   <li><a>valuation</a> -- exponent &lt;math&gt;,</li>
--   <li><a>digits</a> -- list &lt;math&gt; in the canonical p-adic
--   expansion of a number,</li>
--   <li><a>lifted</a> -- digit &lt;math&gt; lifted to modulo
--   &lt;math&gt;.</li>
--   </ul>
--   
--   Rational p-adic number is represented as a unit (belonging to
--   &lt;math&gt; ) and valuation, which may be negative.
--   
--   The radix &lt;math&gt; of a p-adic number is specified at a type level
--   via type-literals. In order to use them GHCi should be loaded with
--   `-XDataKinds` extensions.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; 45 :: Z 10
--   45
--   
--   &gt;&gt;&gt; 45 :: Q 5
--   140.0
--   </pre>
--   
--   Negative p-adic integers and rational p-adics have trailing periodic
--   digit sequences, which are represented in parentheses.
--   
--   <pre>
--   &gt;&gt;&gt; -45 :: Z 7
--   (6)04
--   
--   &gt;&gt;&gt; 1/7 :: Q 10
--   (285714)3.0
--   </pre>
--   
--   By default the precision of p-adics is computed so that it is possible
--   to reconstruct integers and rationals using extended Euler's method.
--   However precision could be specified explicitly via type-literal:
--   
--   <pre>
--   &gt;&gt;&gt; sqrt 2 :: Q 7
--   …623164112011266421216213.0
--   
--   &gt;&gt;&gt; sqrt 2 :: Q' 7 5
--   …16213.0
--   
--   &gt;&gt;&gt; sqrt 2 :: Q' 7 50
--   …16244246442640361054365536623164112011266421216213.0
--   </pre>
--   
--   Between types defined in the module there are bijective mappings as
--   shown in the diagram:
--   
--   <pre>
--                          [Mod p]
--                         /       \
--                digits  /         \  digits
--           fromDigits  /           \  fromDigits
--                      /             \
--       toInteger     /   fromUnit    \   fromRational
--   Z &lt;-----------&gt; Z p &lt;----------&gt; Q p &lt;------------&gt; Q
--      fromInteger    \     unit      /    toRational
--                      \             /
--               lifted  \           /  lifted
--                mkUnit  \         /  mkUnit
--                         \       /
--                         Integer
--   </pre>
module Math.NumberTheory.Padic

-- | Integer p-adic number (an element of &lt;math&gt;) with default
--   precision.
type Z p = Z' p (SufficientPrecision Word32 p)

-- | Integer p-adic number with explicitly specified precision.
data Z' (p :: Nat) (prec :: Nat)

-- | Rational p-adic number (an element of &lt;math&gt;) with default
--   precision.
type Q p = Q' p (SufficientPrecision Word32 p)

-- | Rational p-adic number with explicitly specified precision.
data Q' (p :: Nat) (prec :: Nat)

-- | Type family for p-adic numbers with precision defined by
--   reconstructable number type.
--   
--   <pre>
--   &gt;&gt;&gt; 123456 :: Padic Int 7
--   1022634
--   
--   &gt;&gt;&gt; toInteger it
--   123456
--   
--   &gt;&gt;&gt; toRational (12345678987654321 :: Padic (Ratio Word16) 3)
--   537143292837 % 5612526479  -- insufficiend precision for proper reconstruction!!
--   
--   &gt;&gt;&gt; toRational (12345678987654321 :: Padic Rational 3)
--   12345678987654321 % 1
--   </pre>
type family Padic num (p :: Nat)

-- | Precision sufficient for rational reconstruction of number belonging
--   to a type <tt>num</tt>. Used in a type declaration as follows:
--   
--   <pre>
--   &gt;&gt;&gt; x = 1 `div` 1234567898765432123456789 :: Z 2 (Sufficientprecision Word32 2)
--   
--   &gt;&gt;&gt; toRational x
--   13822228938088947473 % 12702006275138148709
--   
--   &gt;&gt;&gt; x = 1 `div` 1234567898765432123456789 :: Z 2 (Sufficientprecision Int 2)
--   
--   &gt;&gt;&gt; toRational x
--   1 % 1234567898765432123456789
--   </pre>
type family SufficientPrecision num (p :: Nat) :: Nat

-- | Constraint for non-zero natural number which can be a radix.
type family ValidRadix (m :: Nat) :: Constraint

-- | Constraint for valid radix of a number
type KnownRadix m = (ValidRadix m, KnownNat m)

-- | Radix of the internal representation of integer p-adic number.
type family LiftedRadix p prec

-- | Constraint for known valid radix of p-adic number as well as it's
--   lifted radix.
type family Radix p prec :: Constraint

-- | Typeclass for p-adic numbers.
class (Eq n, Num n) => PadicNum n

-- | A type for p-adic unit.
type family Unit n

-- | A type for digits of p-adic expansion. Associated type allows to
--   assure that digits will agree with the radix <tt>p</tt> of the number.
type family Digit n

-- | Returns the radix of a number
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; radix (5 :: Z 13)
--   13
--   
--   &gt;&gt;&gt; radix (-5 :: Q' 3 40)
--   3
--   </pre>
radix :: (PadicNum n, Integral i) => n -> i

-- | Returns the precision of a number.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; precision (123 :: Z 2)
--   20
--   
--   &gt;&gt;&gt; precision (123 :: Z' 2 40)
--   40
--   </pre>
precision :: (PadicNum n, Integral i) => n -> i

-- | Returns digits of a digital object
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; digits (123 :: Z 10)
--   [(3 `modulo` 10),(2 `modulo` 10),(1 `modulo` 10),(0 `modulo` 10),(0 `modulo` 10)]
--   
--   &gt;&gt;&gt; take 5 $ digits (-123 :: Z 2)
--   [(1 `modulo` 2),(0 `modulo` 2),(1 `modulo` 2),(0 `modulo` 2),(0 `modulo` 2)]
--   
--   &gt;&gt;&gt; take 5 $ digits (1/300 :: Q 10)
--   [(7 `modulo` 10),(6 `modulo` 10),(6 `modulo` 10),(6 `modulo` 10),(6 `modulo` 10)]
--   </pre>
digits :: PadicNum n => n -> [Digit n]

-- | The least significant digit of a p-adic number. -- -- &gt;&gt;&gt;
--   firstDigit (123 :: Z 10) -- (3 <tt>modulo</tt> 10) -- &gt;&gt;&gt;
--   firstDigit (123 :: Z 257) -- (123 <tt>modulo</tt> 257)
firstDigit :: PadicNum n => n -> Digit n

-- | Returns p-adic number reduced modulo <tt>p</tt>
--   
--   <pre>
--   &gt;&gt;&gt; reduce (123 :: Z 10) :: Mod 100
--   (23 `modulo` 100)
--   </pre>
reduce :: (KnownRadix p, PadicNum n) => n -> Mod p

-- | Constructor for a digital object from it's digits
fromDigits :: PadicNum n => [Digit n] -> n

-- | Returns lifted digits
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; lifted (123 :: Z 10)
--   123
--   
--   &gt;&gt;&gt; lifted (-123 :: Z 10)
--   9999999999999999999999999999999999999999877
--   </pre>
lifted :: PadicNum n => n -> Integer

-- | Creates digital object from it's lifted digits.
mkUnit :: PadicNum n => Integer -> n

-- | Splits p-adic number into unit and valuation.
--   
--   <pre>
--   splitUnit (u * p^v) = (u, v)
--   </pre>
splitUnit :: PadicNum n => n -> (Unit n, Int)

-- | Creates p-adic number from given unit and valuation.
--   
--   <pre>
--   fromUnit (u, v) = u * p^v
--   </pre>
fromUnit :: PadicNum n => (Unit n, Int) -> n

-- | Returns the p-adic unit of a number
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; unit (120 :: Z 10)
--   12
--   
--   &gt;&gt;&gt; unit (75 :: Z 5)
--   3 
--   </pre>
unit :: PadicNum n => n -> Unit n

-- | Returns a p-adic valuation of a number
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; valuation (120 :: Z 10)
--   1
--   
--   &gt;&gt;&gt; valuation (75 :: Z 5)
--   2
--   </pre>
--   
--   Valuation of zero is equal to working precision
--   
--   <pre>
--   &gt;&gt;&gt; valuation (0 :: Q 2)
--   64
--   
--   &gt;&gt;&gt; valuation (0 :: Q 10)
--   21 
--   </pre>
valuation :: PadicNum n => n -> Int

-- | Returns a rational p-adic norm of a number &lt;math&gt;.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; norm (120 :: Z 10)
--   0.1
--   
--   &gt;&gt;&gt; norm (75 :: Z 5)
--   4.0e-2
--   </pre>
norm :: (Integral i, PadicNum n) => n -> Ratio i

-- | Adjusts unit and valuation of p-adic number, by removing trailing
--   zeros from the right-side of the unit.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; x = 2313 + 1387 :: Q 10
--   
--   &gt;&gt;&gt; x
--   3700.0
--   
--   &gt;&gt;&gt; splitUnit x
--   (3700,0)
--   
--   &gt;&gt;&gt; splitUnit (normalize x)
--   (37,2) 
--   </pre>
normalize :: PadicNum n => n -> n

-- | Partial multiplicative inverse of p-adic number (defined both for
--   integer or rational p-adics).
inverse :: PadicNum n => n -> Maybe n

-- | Returns <tt>True</tt> for a p-adic number which is multiplicatively
--   invertible.
isInvertible :: PadicNum n => n -> Bool

-- | Returns <tt>True</tt> for a p-adic number which is equal to zero
--   (within it's precision).
isZero :: PadicNum n => n -> Bool

-- | Extracts p-adic unit from integer number. For radix &lt;math&gt; and
--   integer &lt;math&gt; returns pair &lt;math&gt; such that &lt;math&gt;.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; getUnitZ  10 120
--   (12,1)
--   
--   &gt;&gt;&gt; getUnitZ 2 120
--   (15,3)
--   
--   &gt;&gt;&gt; getUnitZ 3 120
--   (40,1)
--   </pre>
getUnitZ :: (Integral p, Integral n) => p -> n -> (p, Int)

-- | Extracts p-adic unit from a rational number. For radix &lt;math&gt;
--   and rational number &lt;math&gt; returns pair &lt;math&gt; such that
--   &lt;math&gt; and &lt;math&gt;.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; getUnitQ 3 (75/157)
--   (25 % 157, 1)
--   
--   &gt;&gt;&gt; getUnitQ 5 (75/157)
--   (3 % 157, 2)
--   
--   &gt;&gt;&gt; getUnitQ 157 (75/157)
--   (75 % 1, -1)
--   
--   &gt;&gt;&gt; getUnitQ 10 (1/60)
--   (5 % 3, -2)
--   </pre>
getUnitQ :: Integral p => p -> Ratio p -> (Ratio p, Int)

-- | Returns solution of the equation &lt;math&gt; in p-adics. Used as a
--   first step if <a>henselLifting</a> function and is usefull for
--   introspection.
--   
--   <pre>
--   &gt;&gt;&gt; findSolutionMod (\x -&gt; x*x - 2) :: [Z 7]
--   [3,4]
--   
--   &gt;&gt;&gt; findSolutionMod (\x -&gt; x*x - x) :: [Q 10]
--   [0.0,1.0,5.0,6.0]
--   </pre>
findSolutionMod :: (PadicNum n, KnownRadix p, Digit n ~ Mod p) => (n -> n) -> [n]

-- | Returns p-adic solutions (if any) of the equation &lt;math&gt; using
--   Hensel lifting method. First, solutions of &lt;math&gt; are found,
--   then by Newton's method this solution is get lifted to p-adic number
--   (up to specified precision).
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; henselLifting (\x -&gt; x*x - 2) (\x -&gt; 2*x) :: [Z 7]
--   […64112011266421216213,…02554655400245450454]
--   
--   &gt;&gt;&gt; henselLifting (\x -&gt; x*x - x) (\x -&gt; 2*x-1) :: [Q 10]
--   [0,1,…92256259918212890625,…07743740081787109376]
--   </pre>
henselLifting :: (Eq n, PadicNum n, KnownRadix p, Digit n ~ Mod p) => (n -> n) -> (n -> n) -> [n]

-- | Returns a list of m-th roots of unity.
unityRoots :: (KnownRadix p, PadicNum n, Digit n ~ Mod p) => Integer -> [n]

-- | Returns p-adic square root, calculated for odd radix via Hensel
--   lifting, and for &lt;math&gt; by recurrent product.
pSqrt :: (Fractional n, PadicNum n, KnownRadix p, Digit n ~ Mod p) => n -> [n]

-- | Exponentiation for p-adic numbers, calculated as
--   
--   &lt;math&gt;
--   
--   with convergence, corresponding to <a>pExp</a> and <a>pLog</a>
--   functions.
pPow :: (PadicNum p, Fractional p) => p -> p -> Either String p

-- | Integer power function (analog of (^) operator )
zPow :: Radix p prec => Z' p prec -> Z' p prec -> Z' p prec

-- | Returns p-adic exponent function, calculated via Taylor series. For
--   given radix &lt;math&gt; converges for numbers which satisfy
--   inequality:
--   
--   &lt;math&gt;
pExp :: (Eq n, PadicNum n, Fractional n) => n -> Either String n

-- | Returns p-adic logarithm function, calculated via Taylor series. For
--   given radix &lt;math&gt; converges for numbers which satisfy
--   inequality:
--   
--   &lt;math&gt;
pLog :: (Eq b, PadicNum b, Fractional b) => b -> Either String b

-- | Returns p-adic hyperbolic cosine function, calculated via Taylor
--   series. For given radix &lt;math&gt; converges for numbers which
--   satisfy inequality:
--   
--   &lt;math&gt;
pSin :: (PadicNum b, Fractional b) => b -> Either [Char] b

-- | Returns p-adic cosine function, calculated via Taylor series. For
--   given radix &lt;math&gt; converges for numbers which satisfy
--   inequality:
--   
--   &lt;math&gt;
pCos :: (PadicNum b, Fractional b) => b -> Either [Char] b

-- | Returns p-adic hyperbolic sine function, calculated via Taylor series.
--   For given radix &lt;math&gt; converges for numbers which satisfy
--   inequality:
--   
--   &lt;math&gt;
pSinh :: (PadicNum b, Fractional b) => b -> Either [Char] b

-- | Returns p-adic hyperbolic cosine function, calculated via Taylor
--   series. For given radix &lt;math&gt; converges for numbers which
--   satisfy inequality:
--   
--   &lt;math&gt;
pCosh :: (PadicNum b, Fractional b) => b -> Either [Char] b

-- | Returns p-adic hyperbolic tan function, calculated as
--   
--   &lt;math&gt;
--   
--   with convergence, corresponding to <a>pSinh</a> and <a>pCosh</a>
--   functions.
pTanh :: (Fractional b, PadicNum b) => b -> Either [Char] b

-- | Returns p-adic arcsine function, calculated via Taylor series. For
--   given radix &lt;math&gt; converges for numbers which satisfy
--   inequality:
--   
--   &lt;math&gt;
pAsin :: (Fractional b, PadicNum b) => b -> Either [Char] b

-- | Returns p-adic inverse hyperbolic sine function, calculated as
--   
--   &lt;math&gt;
--   
--   with convergence, corresponding to <a>pLog</a> and <a>pPow</a>
--   functions.
pAsinh :: (PadicNum b, Fractional b) => b -> Either String b

-- | Returns p-adic inverse hyperbolic cosine function, calculated as
--   
--   &lt;math&gt;
--   
--   with convergence, corresponding to <a>pLog</a> and <a>pPow</a>
--   functions.
pAcosh :: (PadicNum b, Fractional b) => b -> Either String b

-- | Returns p-adic inverse hyperbolic tan function, calculated as
--   
--   &lt;math&gt;
--   
--   with convergence, corresponding to <a>pLog</a> function.
pAtanh :: (PadicNum b, Fractional b) => b -> Either String b

-- | Folds a list of digits (integers modulo <tt>p</tt>) to a number.
fromRadix :: KnownRadix p => [Mod p] -> Integer

-- | Unfolds a number to a list of digits (integers modulo <tt>p</tt>).
toRadix :: KnownRadix p => Integer -> [Mod p]

-- | For a given list extracts prefix and a cycle, limiting length of
--   prefix and cycle by <tt>len</tt>. Uses the modified tortiose-and-hare
--   method.
findCycle :: Eq a => Int -> [a] -> Maybe ([a], [a])

-- | For given radix &lt;math&gt; and natural number &lt;math&gt; returns
--   precision sufficient for rational reconstruction of fractions with
--   numerator and denominator not exceeding &lt;math&gt;.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; sufficientPrecision 2 (maxBound :: Int)
--   64
--   
--   &gt;&gt;&gt; sufficientPrecision 3 (maxBound :: Int)
--   41
--   
--   &gt;&gt;&gt; sufficientPrecision 10 (maxBound :: Int)
--   20
--   </pre>
sufficientPrecision :: Integral a => Integer -> a -> Integer
